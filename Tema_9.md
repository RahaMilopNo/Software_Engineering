# Тема 9. Концепции и принципы ООП
Отчет по Теме #9 выполнил(а):
- Куликов Максим Александрович
- ИВТ-22-1

| Задание    | Лаб_раб | Сам_раб |
|------------|---------| ------ |
| Задание 1  | +       | + |
| Задание 2  | +       |  |
| Задание 3  | +       |  |
| Задание 4  | +       |  |
| Задание 5  | +       |  |

знак "+" - задание выполнено; знак "-" - задание не выполнено;

Работу проверили:
- к.э.н., доцент Панов М.А.

## Лабораторная работа 9
## Задание №1
### Допустим, что вы решили оригинально и немного странно познакомится с человеком. Для этого у вас должен быть написан свой класс на Python, который будет проверять угадал ваше имя человек или нет. Для этого создайте класс, указав в свойствах только имя. Дальше создайте функцию __init__(), а в ней сделайте проверку на то угадал человек ваше имя или нет. Также можете проверить что будет, если в этой функции указав атрибут, который не указан в вашем классе, например, попробуйте вызвать фамилию
```python
class Ivan:
    __slots__ = ['name']

    def __init__(self, name):
        if name == 'Иван':
            self.name = f"Да, я {name}"
        else:
            self.name = f"Я не {name}, а Иван"

person1 = Ivan('Алексей')
person2 = Ivan('Иван')

print(person1.name)
print(person2.name)
person2.surname = 'Петров'
```
### ![Результат](https://github.com/RahaMilopNo/Software_Engineering/blob/Tema_9/theme_9/screen/lab9_1.png)
## Вывод
При вызове фамилии выводится ошибка: AttributeError: 'Ivan' object has no attribute 'surname'. Это связано с тем, что использование __slots__ ограничивает объект только теми атрибутами, которые явно указаны в списке. В коде класс Ivan ограничен атрибутом name, попытка добавить новый атрибут surname вызовет исключение.

## Задание №2
### Вам дали важное задание, написать продавцу мороженого программу, которая будет писать добавили ли топпинг в мороженое и цену после возможного изменения. Для этого вам нужно написать класс, в котором будет определяться изменили ли состав мороженого или нет. В этом классе реализуйте метод, выводящий на печать «Мороженое с {ТОППИНГ}» в случае наличия добавки, а иначе отобразится следующая фраза: «Обычное мороженое». При этом программа должна воспринимать как топпинг только атрибуты типа string.
```python
class Icecream:
    def __init__(self, ingredient = None):
        if isinstance(ingredient, str):
            self.ingredient = ingredient
        else:
            self.ingredient = None

    def compostion(self):
        if self.ingredient:
            print(f"Мороженое с {self.ingredient}")
        else:
            print('Обычное мороженое')

iceream = Icecream()
iceream.compostion()
iceream = Icecream('шоколадом')
iceream.compostion()
iceream = Icecream(5)
iceream.compostion()
```
### ![Результат](https://github.com/RahaMilopNo/Software_Engineering/blob/Tema_9/theme_9/screen/lab9_2.png)
## Вывод
В ходе выполнения задания был разработан класс Icecream, который позволяет реализовать функциональность для отслеживания наличия топпинга в мороженом. Класс успешно проверяет тип ингредиента.

## Задание №3
### Петя – начинающий программист и на занятиях ему сказали реализовать икапсу…что-то. А вы хороший друг Пети и ко всему прочему прекрасно знаете, что икапсу…что-то – это инкапсуляция, поэтому решаете помочь вашему другу с написанием класса с инкапсуляцией. Ваш класс будет не просто инкапсуляцией, а классом с сеттером, геттером и деструктором. После написания класса вам необходимо продемонстрировать что все написанные вами функции работают.Также вас необходимо объяснить Пете почему на скриншоте ниже в консоли выводится ошибка.
```python
class MyClass:
    def __init__(self, value):
        self._value = value

    def set_value(self, value):
        self._value = value

    def get_value(self):
        if hasattr(self, '_value'):  # Проверка существования атрибута
            return self._value
        else:
            return "Атрибут _value не существует"

    def del_value(self):
        del self._value
    
    value = property(get_value, set_value, del_value, "Свойство value")

obj = MyClass(42)
print(obj.get_value())
obj.set_value(45)
print(obj.get_value())
obj.set_value(100)
print(obj.get_value())
obj.del_value()
print(obj.get_value())
```
### ![Результат](https://github.com/RahaMilopNo/Software_Engineering/blob/Tema_9/theme_9/screen/lab9_3.png)
## Вывод
Ошибка возникает из-за того, что после вызова метода del_value(), атрибут _value был удалён из объекта, и когда программа пытается снова вызвать метод get_value() и получить доступ к несуществующему атрибуту _value, это приводит к ошибке AttributeError.

## Задание №4
### Вам прекрасно известно, что кошки и собаки являются млекопитающими, но компьютер этого не понимает, поэтому вам нужно написать три класса: Кошки, Собаки, Млекопитающие. И при помощи “наследования” объяснить компьютеру что кошки и собаки – это млекопитающие. Также добавьте какой-нибудь свой атрибут для кошек и собак, чтобы показать, что они чем-то отличаются друг от друга.
```python
class Mammal:
    className = 'Mammal'

class Dog(Mammal):
    species = 'canine'
    sounds = 'wow'

class Cat(Mammal):
    species = 'feline'
    sounds = 'meow'

dog = Dog()
print(f"Dog is {dog.className}, but they say {dog.sounds}")
cat = Cat()
print(f"Cat is {cat.className}, but they say {cat.sounds}")
```
### ![Результат](https://github.com/RahaMilopNo/Software_Engineering/blob/Tema_9/theme_9/screen/lab9_4.png)
## Вывод
В ходе выполнения задания была разработана иерархия классов, демонстрирующая концепцию наследования в объектно-ориентированном программировании. Созданы три класса: Mammal, Dog и Cat, где Dog и Cat наследуют свойства от класса Mammal, что позволяет компьютеру понимать, что кошки и собаки являются млекопитающими.

## Задание №5
### На разных языках здороваются по-разному, но суть остается одинаковой, люди друг с другом здороваются. Давайте вместе с вами реализуем программу с полиморфизмом, которая будет описывать всю суть первого предложения задачи. Для этого мы можем выбрать два языка, например, русский и английский и написать для них отдельные классы, в которых будет в виде атрибута слово, которым здороваются на этих языках. А также напишем функцию, которая будет выводить информацию о том, как на этих языках здороваются.Заметьте, что для решения поставленной задачи мы использовали декоратор @staticmethod, поскольку нам не нужны обязательныепараметры-ссылки вроде self.
```python
class Russian:
    @staticmethod
    def greeting():
        print("Привет")

class English:
    @staticmethod
    def greeting():
        print("Hello")

def greet(language):
    language.greeting()

ivan = Russian()
greet(ivan)
john = English()
greet(john)
```
### ![Результат](https://github.com/RahaMilopNo/Software_Engineering/blob/Tema_9/theme_9/screen/lab9_5.png)
## Вывод
В рамках выполнения задания была реализована программа, демонстрирующая полиморфизм с помощью классов, отвечающих за приветствие на разных языках. Созданы два класса: Russian и English, каждый из которых имеет статический метод greeting(), выводящий соответствующее приветствие.


## Самостоятельная работа 9
## Задание: Садовник и помидоры.
### Классовая структура:
### Есть Помидор со следующими характеристиками:
-  Индекс
-  Стадия созревания (стадии: отсутствует, цветение, зеленый, красный)
### Помидор может:
- Расти (переходить на следующую стадию созревания)
- Предоставлять информацию о своей зрелости
### Есть Куст с помидорами, который:
- Содержит список томатов, которые на нем растут
### А также может:
- Расти вместе с томатами
- Предоставлять информацию о зрелости всех томатов
- Предоставлять урожай
### И также есть Садовник, который имеет:
- Имя
- Растение, за которым он ухаживает
### Он может:
- Ухаживать за растением
- Собирать с него урожай

## Задание:
### Класс Tomato:
1. Создайте класс Tomato
2. Создайте статическое свойство states, которое будет содержать все стадии созревания помидора
3. Создайте метод __init__(), внутри которого будут определены два динамических свойства: _index (передается параметром) и _state (принимает первое значение из словаря states). После написания этого блока кода в комментарии к нему укажите какими являются эти два свойства
4. Создайте метод grow(), который будет переводить томат на следующую стадию созревания
5. Создайте метод is_ripe(), который будет проверять, что томат созрел

### Класс TomatoBush:
1. Создайте класс TomatoBush
2. Определите метод __init__(), который будет принимать в качестве параметра количество томатов и на его основе будет создавать список объектов класса Tomato. Данный список будет храниться внутри динамического свойства tomatoes
3. Создайте метод grow_all(), который будет переводить все объекты из списка томатов на следующий этап созревания
4. Создайте метод all_are_ripe(), который будет возвращать True, если все томаты из списка стали спелыми.
5. Создайте метод give_away_all(), который будет чистить список томатов после сбора урожая

### Класс Gardener:
1. Создайте класс Gardener
2. Создайте метод __init__(), внутри которого будут определены два динамических свойства: name (передается параметром, является публичным) и _plant (принимает объект класса TomatoBush). После написания этого блока кода в комментарии к нему укажите какими являются эти два свойства
3. Создайте метод work(), который заставляет садовника работать, что позволяет растению становиться более зрелым
4. Создайте метод harvest(), который проверяет, все ли плоды созрели. Если все, то садовник собирает урожай. Если нет, то метод печатает предупреждение
5. Создайте статический метод knowledge_base(), который выведет в консоль справку по садоводству

### Тесты:
1. Вызовите справку по садоводству
2. Создайте объекты классов TomatoBush и Gardener
3. Используя объект класса Gardener, поухаживайте за кустом с помидорами
4. Попробуйте собрать урожай, когда томаты еще не дозрели. Продолжайте ухаживать за ними
5. Соберите урожай

Результатом работы вашей программы будет листинг кода с подробными комментариями и скриншоты выполенния всех тестов.

```python
class Tomato:
    # Статическое свойство, содержащее все стадии созревания помидора
    states = ['absent', 'flowering', 'green', 'red']

    def __init__(self, index):
        # Динамические свойства: _index (индекс) и _state (стадия созревания)
        self._index = index
        self._state = self.states[0]  # Начальная стадия - отсутствует

    def grow(self):
        # Переход на следующую стадию созревания
        current_state_index = self.states.index(self._state)
        if current_state_index < len(self.states) - 1:
            self._state = self.states[current_state_index + 1]

    def is_ripe(self):
        # Проверка что томат созрел
        return self._state == 'red'


class TomatoBush:
    def __init__(self, tomato_count):
        # Динамическое свойство: tomatoes (список томатов)
        self.tomatoes = [Tomato(i) for i in range(tomato_count)]

    def grow_all(self):
        # Переход всех томатов на следующий этап созревания
        for tomato in self.tomatoes:
            tomato.grow()

    def all_are_ripe(self):
        # Проверка, созрели ли все томаты
        return all(tomato.is_ripe() for tomato in self.tomatoes)

    def give_away_all(self):
        # Удаление всех томатов после сбора урожая
        self.tomatoes.clear()


class Gardener:
    def __init__(self, name, plant):
        # Динамические свойства: name (имя садовника) и _plant (куст помидоров)
        self.name = name
        self._plant = plant

    def work(self):
        # Ухаживание за растением, приводит к росту томатов
        self._plant.grow_all()

    def harvest(self):
        # Проверка, все ли плоды созрели
        if self._plant.all_are_ripe():
            print(f"{self.name} собрал все помидоры!")
            self._plant.give_away_all()
        else:
            print(f"{self.name} говорит: Еще не все помидоры созрели!")

    @staticmethod
    def knowledge_base():
        # Справка по садоводству
        print("База знаний по садоводству:")
        print("1. Регулярно поливайте растения.")
        print("2. Обеспечьте им достаточное количество солнечного света.")
        print("3. Удалите все отмершие листья и вредителей.")
        print("4. Будьте терпеливы, ведь растениям требуется время, чтобы вырасти.")


# Тесты
Gardener.knowledge_base()  # Вызов справки по садоводству

# Создание объектов классов
bush = TomatoBush(5)  # Создаем куст с 5 помидорами
gardener = Gardener("Максим", bush)  # Создаем садовника с именем "Максим" и кустом

# Уход за кустом
gardener.work()  # Ухаживаем за кустом с помидорами
gardener.harvest()  # Пытаемся собрать урожай, когда томаты еще не дозрели

# Продолжаем ухаживать
gardener.work()  # Ухаживаем за кустом снова
gardener.harvest()  # Пытаемся собрать урожай снова

# Ухаживаем до полного созревания
for _ in range(3):
    gardener.work()  # Ухаживаем за кустом

gardener.harvest()  # Собираем урожай
```

### ![Результат](https://github.com/RahaMilopNo/Software_Engineering/blob/Tema_9/theme_9/screen/sam9_1.png)
### ![Результат](https://github.com/RahaMilopNo/Software_Engineering/blob/Tema_9/theme_9/screen/sam9_1_1.png)
### ![Результат](https://github.com/RahaMilopNo/Software_Engineering/blob/Tema_9/theme_9/screen/sam9_1_2.png)
### ![Результат](https://github.com/RahaMilopNo/Software_Engineering/blob/Tema_9/theme_9/screen/sam9_1_3.png)
## Вывод
В ходе выполнения задания была разработана программа, моделирующая процесс ухода за помидорами с использованием объектно-ориентированного подхода. Созданы три класса: Tomato, TomatoBush и Gardener, каждый из которых выполняет свои функции и взаимодействует друг с другом.

## Общие выводы по теме
В ходе изучения концепций и принципов объектно-ориентированного программирования была достигнута глубокое понимание ключевых понятий, таких как наследование, полиморфизм и инкапсуляция. Создание классов и работа с ними позволило освоить важные аспекты структурирования кода и его повторного использования.
